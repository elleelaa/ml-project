# -*- coding: utf-8 -*-
"""rock-paper-scissor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oaOcFAow6kGyPxD6TByxqs9KKRGZXDHK

#**Ml project : a model that predicts the next player's move based on previous patters**
"""

!pip install pandas scikit-learn numpy

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

data = {
    'Move1': [0, 1, 2, 0, 1, 2, 0, 1, 2],  # Rock=0, Paper=1, Scissors=2
    'Move2': [1, 2, 0, 1, 2, 0, 1, 2, 0],
    'Move3': [2, 0, 1, 2, 0, 1, 2, 0, 1],
    'NextMove': [0, 1, 2, 0, 1, 2, 0, 1, 2]
}
df=pd.DataFrame(data)
df

df.to_csv('rps_data.csv', index=False)

print(df.head())

"""###**preparing the data for training**"""

# Features: Last 3 moves
X = df[['Move1', 'Move2', 'Move3']]

# Labels: Next move
y = df['NextMove']

"""###**splitind data into training and testing**"""

# Split the data: 80% for training, 20% for testing
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

knn = KNeighborsClassifier(n_neighbors=3)
knn.fit(X_train , y_train)

# Predict the next move for the test data
y_pred = knn.predict(X_test)
print("Predicted Moves:", y_pred)

# Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

new_moves = np.array([[1, 2, 0]])
predicted_move = knn.predict(new_moves)
print("Predicted Next Move:", predicted_move)

import joblib
joblib.dump(knn, 'rps_knn_model.pkl')

pip install streamlit

import streamlit as st
import joblib
import numpy as np

# Load the smart helper (KNN model)
model = joblib.load('rps_knn_model.pkl')

# Title of the app
st.title("Rock-Paper-Scissors Game")

# Instructions
st.write("""
### How to Play:
1. Choose your move: Rock, Paper, or Scissors.
2. Click "Play" to see what the computer predicts and who wins!
""")

# Dropdown for the player to choose their move
player_move = st.selectbox("Your Move", ["Rock", "Paper", "Scissors"])

# Convert the move to a number (Rock=0, Paper=1, Scissors=2)
move_to_number = {"Rock": 0, "Paper": 1, "Scissors": 2}
player_move_number = move_to_number[player_move]

# Predict the computer's move
if st.button("Play"):
    # Use the last 3 moves (if available) to predict
    if 'history' not in st.session_state:
        st.session_state.history = []

    if len(st.session_state.history) >= 3:
        input_data = np.array([st.session_state.history[-3:]])
        ai_move_number = model.predict(input_data)[0]
    else:
        # If there's not enough history, pick a random move
        ai_move_number = np.random.randint(0, 3)

    # Convert the computer's move back to a name
    number_to_move = {0: "Rock", 1: "Paper", 2: "Scissors"}
    ai_move = number_to_move[ai_move_number]

    # Show the results
    st.write(f"Your Move: **{player_move}**")
    st.write(f"Computer's Move: **{ai_move}**")

    # Determine the winner
    if player_move_number == ai_move_number:
        st.write("**It's a tie!**")
    elif (player_move_number - ai_move_number) % 3 == 1:
        st.write("**You win!**")
    else:
        st.write("**Computer wins!**")

    # Update the game history
    st.session_state.history.append(player_move_number)

# Display game history
st.write("### Game History")
if 'history' in st.session_state and st.session_state.history:
    history_moves = [number_to_move[move] for move in st.session_state.history]
    for i, move in enumerate(history_moves, 1):
        st.write(f"Round {i}: {move}")
else:
    st.write("No moves played yet.")

!streamlit run app.py